;
; File generated by cc65 v 2.15
;
	.fopt		compiler,"cc65 v 2.15"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_pal_bg
	.import		_pal_spr
	.import		_ppu_wait_nmi
	.import		_ppu_off
	.import		_ppu_on_all
	.import		_oam_clear
	.import		_oam_meta_spr
	.import		_pad_poll
	.import		_bank_spr
	.import		_vram_adr
	.import		_vram_put
	.import		_vram_unrle
	.import		_memcpy
	.import		_set_vram_buffer
	.import		_one_vram_buffer
	.import		_clear_vram_buffer
	.import		_get_pad_new
	.import		_check_collision
	.import		_set_scroll_y
	.import		_get_ppu_addr
	.export		_PaddleSpr
	.export		_BallSpr
	.export		_breaky_bg2
	.export		_c1
	.export		_sprid
	.export		_pad1
	.export		_pad1_new
	.export		_collision
	.export		_temp1
	.export		_temp_x
	.export		_temp_y
	.export		_address
	.export		_lives01
	.export		_score10
	.export		_score01
	.export		_ball_state
	.export		_ball_x_rel
	.export		_ball_count
	.export		_ball_direction
	.export		_c_map
	.export		_Paddle
	.export		_Ball
	.export		_palette_bg
	.export		_palette_sp
	.export		_draw_bg
	.export		_draw_sprites
	.export		_movement
	.export		_score_lives_draw
	.export		_adjust_score
	.export		_hit_block
	.export		_main

.segment	"DATA"

_lives01:
	.byte	$03
_Paddle:
	.byte	$75
	.byte	$D0
	.byte	$1F
	.byte	$07
_Ball:
	.byte	$FF
	.byte	$FF
	.byte	$05
	.byte	$05

.segment	"RODATA"

_PaddleSpr:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$18
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$80
_BallSpr:
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$00
	.byte	$80
_breaky_bg2:
	.byte	$01
	.byte	$10
	.byte	$01
	.byte	$41
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$00
	.byte	$53
	.byte	$43
	.byte	$4F
	.byte	$52
	.byte	$45
	.byte	$3A
	.byte	$30
	.byte	$30
	.byte	$00
	.byte	$00
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$00
	.byte	$4C
	.byte	$49
	.byte	$56
	.byte	$45
	.byte	$53
	.byte	$3A
	.byte	$30
	.byte	$30
	.byte	$00
	.byte	$00
	.byte	$10
	.byte	$01
	.byte	$43
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$07
	.byte	$C0
	.byte	$F0
	.byte	$01
	.byte	$05
	.byte	$30
	.byte	$84
	.byte	$A5
	.byte	$01
	.byte	$05
	.byte	$21
	.byte	$4C
	.byte	$5F
	.byte	$01
	.byte	$05
	.byte	$13
	.byte	$C8
	.byte	$FA
	.byte	$01
	.byte	$05
	.byte	$32
	.byte	$84
	.byte	$A5
	.byte	$01
	.byte	$05
	.byte	$21
	.byte	$00
	.byte	$01
	.byte	$0E
	.byte	$00
	.byte	$01
	.byte	$00
_c1:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_palette_bg:
	.byte	$0F
	.byte	$00
	.byte	$10
	.byte	$30
	.byte	$0F
	.byte	$01
	.byte	$21
	.byte	$39
	.byte	$0F
	.byte	$04
	.byte	$24
	.byte	$36
	.byte	$0F
	.byte	$09
	.byte	$29
	.byte	$38
_palette_sp:
	.byte	$0F
	.byte	$00
	.byte	$10
	.byte	$30
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00

.segment	"BSS"

.segment	"ZEROPAGE"
_sprid:
	.res	1,$00
_pad1:
	.res	1,$00
_pad1_new:
	.res	1,$00
_collision:
	.res	1,$00
_temp1:
	.res	1,$00
_temp_x:
	.res	1,$00
_temp_y:
	.res	1,$00
_address:
	.res	2,$00
_score10:
	.res	1,$00
_score01:
	.res	1,$00
_ball_state:
	.res	1,$00
_ball_x_rel:
	.res	1,$00
_ball_count:
	.res	1,$00
_ball_direction:
	.res	1,$00
.segment	"BSS"
_c_map:
	.res	256,$00

; ---------------------------------------------------------------
; void __near__ draw_bg (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_bg: near

.segment	"CODE"

;
; ppu_off(); // screen off
;
	jsr     _ppu_off
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; vram_unrle(breaky_bg2);
;
	lda     #<(_breaky_bg2)
	ldx     #>(_breaky_bg2)
	jsr     _vram_unrle
;
; memcpy (c_map, c1, 256);
;
	ldy     #$00
L024D:	lda     _c1,y
	sta     _c_map,y
	iny
	bne     L024D
;
; vram_adr(NTADR_A(0,6));
;
	ldx     #$20
	lda     #$C0
	jsr     _vram_adr
;
; for(temp_y = 0; temp_y < 16; ++temp_y){
;
	lda     #$00
	sta     _temp_y
L035B:	lda     _temp_y
	cmp     #$10
	bcs     L0256
;
; for(temp_x = 0; temp_x < 16; ++temp_x){
;
	lda     #$00
	sta     _temp_x
L035C:	lda     _temp_x
	cmp     #$10
	bcs     L035F
;
; temp1 = (temp_y << 4) + temp_x;
;
	lda     _temp_y
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     _temp_x
	sta     _temp1
;
; if((temp_x == 0) || (temp_x == 15)) {
;
	lda     _temp_x
	beq     L035D
	cmp     #$0F
	bne     L0268
;
; vram_put(0x10); // wall at the edges
;
L035D:	lda     #$10
	jsr     _vram_put
;
; vram_put(0x10);
;
	lda     #$10
;
; else {
;
	jmp     L035A
;
; if(c_map[temp1]){ // if block = yes
;
L0268:	ldy     _temp1
	lda     _c_map,y
	beq     L035E
;
; vram_put(0x11); // draw block
;
	lda     #$11
	jsr     _vram_put
;
; vram_put(0x12);
;
	lda     #$12
;
; else{
;
	jmp     L035A
;
; vram_put(0); // else draw blank
;
L035E:	jsr     _vram_put
;
; vram_put(0);
;
	lda     #$00
L035A:	jsr     _vram_put
;
; for(temp_x = 0; temp_x < 16; ++temp_x){
;
	inc     _temp_x
	jmp     L035C
;
; for(temp_y = 0; temp_y < 16; ++temp_y){
;
L035F:	inc     _temp_y
	jmp     L035B
;
; ppu_on_all();
;
L0256:	jmp     _ppu_on_all

.endproc

; ---------------------------------------------------------------
; void __near__ draw_sprites (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_sprites: near

.segment	"CODE"

;
; oam_clear();
;
	jsr     _oam_clear
;
; sprid = 0;
;
	lda     #$00
	sta     _sprid
;
; sprid = oam_meta_spr(Paddle.X, Paddle.Y, sprid, PaddleSpr);
;
	jsr     decsp3
	lda     _Paddle
	ldy     #$02
	sta     (sp),y
	lda     _Paddle+1
	dey
	sta     (sp),y
	lda     _sprid
	dey
	sta     (sp),y
	lda     #<(_PaddleSpr)
	ldx     #>(_PaddleSpr)
	jsr     _oam_meta_spr
	sta     _sprid
;
; sprid = oam_meta_spr(Ball.X, Ball.Y, sprid, BallSpr);
;
	jsr     decsp3
	lda     _Ball
	ldy     #$02
	sta     (sp),y
	lda     _Ball+1
	dey
	sta     (sp),y
	lda     _sprid
	dey
	sta     (sp),y
	lda     #<(_BallSpr)
	ldx     #>(_BallSpr)
	jsr     _oam_meta_spr
	sta     _sprid
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ movement (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_movement: near

.segment	"CODE"

;
; if(pad1 & PAD_LEFT){
;
	lda     _pad1
	and     #$02
	beq     L0363
;
; Paddle.X -= 2;
;
	lda     _Paddle
	sec
	sbc     #$02
	sta     _Paddle
;
; if(Paddle.X < PADDLE_MIN) Paddle.X = PADDLE_MIN;
;
	cmp     #$10
	bcs     L0363
	lda     #$10
	sta     _Paddle
;
; if(pad1 & PAD_RIGHT){
;
L0363:	lda     _pad1
	and     #$01
	beq     L0364
;
; Paddle.X += 2;
;
	lda     #$02
	clc
	adc     _Paddle
	sta     _Paddle
;
; if(Paddle.X > PADDLE_MAX) Paddle.X = PADDLE_MAX;
;
	cmp     #$D1
	bcc     L0364
	lda     #$D0
	sta     _Paddle
;
; if(ball_state == BALL_OFF){ // ball is inactive, wait a second
;
L0364:	lda     _ball_state
	bne     L0366
;
; ++ball_count;
;
	inc     _ball_count
;
; if(ball_count > 60){
;
	lda     _ball_count
	cmp     #$3D
	bcc     L0365
;
; ball_state = BALL_STUCK;
;
	lda     #$01
	sta     _ball_state
;
; ball_x_rel = 0x0d;
;
	lda     #$0D
	sta     _ball_x_rel
;
; ball_count = 0;
;
	lda     #$00
	sta     _ball_count
;
; return;
;
	rts
;
; Ball.Y = 0xff; // off screen
;
L0365:	lda     #$FF
	sta     _Ball+1
;
; if(ball_state == BALL_STUCK){ // ball is stuck to the paddle
;
L0366:	lda     _ball_state
	cmp     #$01
	bne     L0368
;
; Ball.X = Paddle.X + ball_x_rel;
;
	lda     _Paddle
	clc
	adc     _ball_x_rel
	sta     _Ball
;
; Ball.Y = Paddle.Y - 4;
;
	lda     _Paddle+1
	sec
	sbc     #$04
	sta     _Ball+1
;
; if(pad1_new & (PAD_A | PAD_B)){ // any new a or b press to start
;
	lda     _pad1_new
	and     #$C0
	beq     L0368
;
; ball_state = BALL_ACTIVE;
;
	lda     #$02
	sta     _ball_state
;
; ball_direction = GOING_UP;
;
	lda     #$00
	sta     _ball_direction
;
; if(Ball.X < BALL_MIN) Ball.X = BALL_MIN;
;
	lda     _Ball
	cmp     #$10
	bcs     L0367
	lda     #$10
	sta     _Ball
;
; if(Ball.X > BALL_MAX) Ball.X = BALL_MAX;
;
L0367:	lda     _Ball
	cmp     #$EB
	bcs     L036E
;
; } 
;
	rts
;
; if(Ball.X > BALL_MAX) Ball.X = BALL_MAX;
;
L036E:	lda     #$EA
	sta     _Ball
;
; return;
;
	rts
;
; if(ball_state == BALL_ACTIVE){
;
L0368:	lda     _ball_state
	cmp     #$02
	beq     L036F
;
; } 
;
	rts
;
; if(ball_direction == GOING_UP){
;
L036F:	lda     _ball_direction
	bne     L0369
;
; Ball.Y -= 3;
;
	lda     _Ball+1
	sec
	sbc     #$03
	sta     _Ball+1
;
; if(Ball.Y < MAX_UP){
;
	cmp     #$30
	bcs     L036A
;
; ball_direction = GOING_DOWN;
;
	lda     #$01
	sta     _ball_direction
;
; else { // going down
;
	jmp     L036A
;
; Ball.Y += 3;
;
L0369:	lda     #$03
	clc
	adc     _Ball+1
	sta     _Ball+1
;
; if(Ball.Y > MAX_DOWN){
;
	cmp     #$E1
	bcc     L02D1
;
; --lives01;
;
	dec     _lives01
;
; ball_state = BALL_OFF;
;
	lda     #$00
	sta     _ball_state
;
; collision = check_collision(&Ball, &Paddle);
;
L02D1:	lda     #<(_Ball)
	ldx     #>(_Ball)
	jsr     pushax
	lda     #<(_Paddle)
	ldx     #>(_Paddle)
	jsr     _check_collision
	sta     _collision
;
; if(collision){
;
	lda     _collision
	beq     L036A
;
; ball_state = BALL_STUCK;
;
	lda     #$01
	sta     _ball_state
;
; ball_x_rel = Ball.X - Paddle.X;
;
	lda     _Ball
	sec
	sbc     _Paddle
	sta     _ball_x_rel
;
; temp_x = (Ball.X + 1) & 0xf0; // tiles are 16 px wide
;
L036A:	lda     _Ball
	clc
	adc     #$01
	and     #$F0
	sta     _temp_x
;
; temp_y = (Ball.Y + 2) & 0xf8; // tiles only 8 px high
;
	lda     _Ball+1
	clc
	adc     #$02
	and     #$F8
	sta     _temp_y
;
; if(temp_y < 0xaf){ // Y of 0x30 + 16*8 = b0. Ball.Y>b0 = off the c_map
;
	cmp     #$AF
	bcs     L036C
;
; temp1 = (temp_x>>4) + (((temp_y-0x30) << 1) & 0xf0);
;
	lda     _temp_x
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _temp_y
	sec
	sbc     #$30
	asl     a
	and     #$F0
	clc
	adc     ptr1
	sta     _temp1
;
; if(c_map[temp1]){ // hit a block
;
	ldy     _temp1
	lda     _c_map,y
;
; hit_block();
;
	jne     _hit_block
;
; temp_x = (Ball.X + 4) & 0xf0; // tiles are 16 px wide
;
L036C:	lda     _Ball
	clc
	adc     #$04
	and     #$F0
	sta     _temp_x
;
; temp_y = (Ball.Y + 2) & 0xf8; // tiles only 8 px high
;
	lda     _Ball+1
	clc
	adc     #$02
	and     #$F8
	sta     _temp_y
;
; if(temp_y < 0xaf){ // Y of 0x30 + 16*8 = b0. Ball.Y>b0 = off the c_map
;
	cmp     #$AF
	bcs     L0307
;
; temp1 = (temp_x>>4) + (((temp_y-0x30) << 1) & 0xf0);
;
	lda     _temp_x
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _temp_y
	sec
	sbc     #$30
	asl     a
	and     #$F0
	clc
	adc     ptr1
	sta     _temp1
;
; if(c_map[temp1]){ // hit a block
;
	ldy     _temp1
	lda     _c_map,y
;
; hit_block();
;
	jne     _hit_block
;
; } 
;
L0307:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ score_lives_draw (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_score_lives_draw: near

.segment	"CODE"

;
; temp1 = score10 + '0';
;
	lda     _score10
	clc
	adc     #$30
	sta     _temp1
;
; one_vram_buffer(temp1, NTADR_A(10,3));
;
	jsr     pusha
	ldx     #$20
	lda     #$6A
	jsr     _one_vram_buffer
;
; temp1 = score01 + '0';
;
	lda     _score01
	clc
	adc     #$30
	sta     _temp1
;
; one_vram_buffer(temp1, NTADR_A(11,3));
;
	jsr     pusha
	ldx     #$20
	lda     #$6B
	jsr     _one_vram_buffer
;
; temp1 = '0';
;
	lda     #$30
	sta     _temp1
;
; one_vram_buffer(temp1, NTADR_A(26,3));
;
	jsr     pusha
	ldx     #$20
	lda     #$7A
	jsr     _one_vram_buffer
;
; temp1 = lives01 + '0';
;
	lda     _lives01
	clc
	adc     #$30
	sta     _temp1
;
; one_vram_buffer(temp1, NTADR_A(27,3));
;
	jsr     pusha
	ldx     #$20
	lda     #$7B
	jmp     _one_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ adjust_score (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_adjust_score: near

.segment	"CODE"

;
; if (score01 >= 10){
;
	lda     _score01
	cmp     #$0A
	bcc     L0354
;
; score01 -= 10;
;
	sec
	sbc     #$0A
	sta     _score01
;
; ++score10;
;
	inc     _score10
;
; }
;
L0354:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ hit_block (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hit_block: near

.segment	"CODE"

;
; score01 += 1;
;
	inc     _score01
;
; adjust_score();
;
	jsr     _adjust_score
;
; ball_direction = GOING_DOWN;
;
	lda     #$01
	sta     _ball_direction
;
; Ball.Y +=3;
;
	lda     #$03
	clc
	adc     _Ball+1
	sta     _Ball+1
;
; c_map[temp1] = 0;
;
	ldy     _temp1
	lda     #$00
	sta     _c_map,y
;
; address = get_ppu_addr(0, temp_x, temp_y);
;
	jsr     decsp2
	lda     #$00
	ldy     #$01
	sta     (sp),y
	lda     _temp_x
	dey
	sta     (sp),y
	lda     _temp_y
	jsr     _get_ppu_addr
	sta     _address
	stx     _address+1
;
; address = address & 0xfffe; // start with the left tile
;
	and     #$FE
	sta     _address
	stx     _address+1
;
; one_vram_buffer(0, address); // tile 0 = blank
;
	lda     #$00
	jsr     pusha
	lda     _address
	ldx     _address+1
	jsr     _one_vram_buffer
;
; ++address;
;
	inc     _address
	bne     L0323
	inc     _address+1
;
; one_vram_buffer(0, address); // also the one to the right of it
;
L0323:	lda     #$00
	jsr     pusha
	lda     _address
	ldx     _address+1
	jmp     _one_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; ppu_off(); // screen off
;
	jsr     _ppu_off
;
; pal_bg(palette_bg);
;
	lda     #<(_palette_bg)
	ldx     #>(_palette_bg)
	jsr     _pal_bg
;
; pal_spr(palette_sp);
;
	lda     #<(_palette_sp)
	ldx     #>(_palette_sp)
	jsr     _pal_spr
;
; bank_spr(1);
;
	lda     #$01
	jsr     _bank_spr
;
; set_scroll_y(0xff); // shift the bg down 1 pixel
;
	ldx     #$00
	lda     #$FF
	jsr     _set_scroll_y
;
; draw_bg();
;
	jsr     _draw_bg
;
; set_vram_buffer(); // do at least once, sets a pointer to a buffer
;
	jsr     _set_vram_buffer
;
; clear_vram_buffer();
;
	jsr     _clear_vram_buffer
;
; ppu_wait_nmi(); // wait till beginning of the frame
;
L0230:	jsr     _ppu_wait_nmi
;
; pad1 = pad_poll(0); // read the first controller
;
	lda     #$00
	jsr     _pad_poll
	sta     _pad1
;
; pad1_new = get_pad_new(0); // newly pressed button. do pad_poll first
;
	lda     #$00
	jsr     _get_pad_new
	sta     _pad1_new
;
; clear_vram_buffer(); // do at the beginning of each frame
;
	jsr     _clear_vram_buffer
;
; score_lives_draw();
;
	jsr     _score_lives_draw
;
; if(lives01){
;
	lda     _lives01
	beq     L023D
;
; movement();
;
	jsr     _movement
;
; draw_sprites();
;
	jsr     _draw_sprites
;
; else{
;
	jmp     L0230
;
; oam_clear(); // game over, just turn everything off
;
L023D:	jsr     _oam_clear
;
; while (1){
;
	jmp     L0230

.endproc

